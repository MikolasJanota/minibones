% -*- mode: Noweb; noweb-code-mode: c++-mode -*-
% File:  CoreBased.w
% Author: mikolas
% Created on: Tue, Sep 04, 2012 3:17:28 PM
% Copyright (C) 2012, Mikolas Janota
Implementation of the class [[CoreBased]].

@ Header file.
<<CoreBased.hh>>=
#ifndef COREBASED_W_3637
#define COREBASED_W_3637
<<Definitions and includes>>
<<Class declaration>>
#endif

@ 
<<Definitions and includes>>=
#include <vector>
#include <functional>
#include "MiniSatExt.hh"
#include "auxiliary.hh"
#include "Lifter.hh"
#include "ToolConfig.hh"
#include "Rotatable.hh"
#include "BackboneInformation.hh"
#include "LitBitSet.hh"
using Minisat::MiniSatExt;
using Minisat::Var;
using Minisat::Lit;
using Minisat::vec;


@ 
<<Class declaration>>=
namespace minibones {
  class CoreBased {
  public: <<Public members>>
  private: <<Private members>>
  };
  <<In-line methods implementation>>
}

@
<<Public members>>=
CoreBased(ToolConfig& tool_configuration, 
          std::ostream& output, 
          Var max_id, const CNF& clauses);
virtual ~CoreBased();
bool initialize(); // initialize, returns true iff the instance is SAT
void run();        // start the worker, initialize must be called first.
virtual bool is_backbone(const Lit& literal) const;

@ Sets of literals that might or must be backbones. When we say
might, we mean that it was not decided either way whether it is a
backbone or not. In particular, the two sets are always disjoint.
<<Private members>>=
LitBitSet           might_be; 
LitBitSet           must_be;  

@ 
<<Private members>>=
MiniSatExt          sat_solver;
void process_model(const vec<lbool>& model);        // calls pruning techniques and debones based of the model
void process_pruned_model(const vec<lbool>& model); // debones everything not in the model
inline bool debone(Lit literal);                    // mark a literal as not a backbone
inline void mark_backbone(Lit literal);             // mark a literal as  a backbone

@ 
<<In-line methods implementation>>=
inline bool CoreBased::debone(Lit literal) { 
  assert(!must_be.get(literal));
  return might_be.remove(literal);
}

inline void CoreBased::mark_backbone(Lit literal) { 
  assert(might_be.get(literal));
  might_be.remove(literal);
  must_be.add(literal);
}


@ Implementation.
<<CoreBased.cc>>=
<<CC includes>>
<<Implementation>>


@
<<Implementation>>=
void CoreBased::run() {
  LitBitSet relaxed;
  while (true) {
    vec<Lit> assumptions;
    <<Prepare assumptions>>;
    const bool flipped = sat_solver.solve(assumptions);
    if (flipped) { <<Handle SAT>>; }
    else { <<Handle UNSAT>> }
  }
}

@ Everything was flipped, unschedule the literals.
<<Handle SAT>>=
process_model(sat_solver.model);


@ Impossible to flip, relax core.
<<Handle UNSAT>>=
const auto& conflict = sat_solver.conflict;
if (sat_solver.conflict.size()==1) // A unit conflict means backbone. 
  mark_backbone(conflict[0]); 
for (int i=0; i<conflict.size(); ++i) 
  relaxed.add(~conflict[0]);


@ Put in the assumptions negations of the literals that still might be
backbones and are not relaxed.
<<Prepare assumptions>>=
FOR_EACH(li, might_be) {
  const Lit l = *li;
  if (relaxed.get(l)) continue;
  assumptions.push(l);
}


@
<<CC includes>>=
#include "CoreBased.hh"
using namespace minibones;

